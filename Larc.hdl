/**
 * Single-cycle implementation of the Larc ISA
 */

CHIP Larc {

    PARTS:
    //pc
    PC(in = pcInput , load = true , out = currPC , out[0..11] = imAddress , inc = false , reset = false) ;
    
    //IM
    RAM4K(address = imAddress , out[0..3] = rc , out[4..7] = rb , out[8..11] = ra , out[4..11] = limm ,  out[11] = signExt , out[0..7] = limm2 , out[7] = signExt2 , out[12..15] = opcode) ;

    //Increment PC by 1
    Inc16(in = currPC , out = currPCplusOne) ;

    //Add for bne and beq
    Add16(a = currPCplusOne , b[0..7] = limm , b[8] = signExt  , b[9] = signExt  , b[10] = signExt  , b[11] = signExt  , b[12] = signExt  , b[13] = signExt  , b[14] = signExt  , b[15] = signExt  , out = currPCplusOffset) ;

    //jal selector
    Mux16(a = currPCplusOne , b = rd1Out , sel = jal , out = jalOut ) ;

    //be and bne selector
    Mux16(a = jalOut , b = currPCplusOffset , sel = bneOrbe , out = pcInput ) ;

    //RFWD selector
    Mux4Way16(a[0..7] = false, a[8..15] = limm2 , b[0..7] = limm2 , b[8] = signExt2 , b[9] = signExt2 , b[10] = signExt2 , b[11] = signExt2 , b[12] = signExt2 , b[13] = signExt2 , b[14] = signExt2 , b[15] = signExt2 , c = currPCplusOne , d = rfwd3 ,  sel = rfwd , out = inForWd) ;

    //RF
    RegisterFile(rr1 = rb , rr2 = rc , wr = ra , wd = inForWd, load = rfwrite , rd1 = rd1Out, rd2 = rd2Out) ;

    //SE
    Mux4(a[0..3] = ra , b[0..3] = rc ,  sel = se , out = seOut, out[3] = seOutSign) ;

    //RD1 selector
    Mux16(a = false , b = rd1Out , sel = rd1 , out = rd1Selector) ;

    //RD2/ALU selector
    Mux16(a = rd2Out , b[0..3] = seOut , b[4] = seOutSign , b[5] = seOutSign , b[6] = seOutSign , b[7] = seOutSign , b[8] = seOutSign , b[9] = seOutSign , b[10] = seOutSign , b[11] = seOutSign , b[12] = seOutSign , b[13] = seOutSign , b[14] = seOutSign , b[15] = seOutSign , sel = alu , out = rd2Selector) ;

    //ALU
    ALU(a = rd1Selector , b = rd2Selector , sub = sub , nor = nor , z = z , out = aluOut , out[0..13] = aluOutAddress) ;

    //bne and be circuit
    Not(in = z , out = notZ) ;
    And(a = be , b = z , out = beAndZ) ;
    And(a = bne , b = notZ , out = bneAndNotZ) ;
    Or(a = beAndZ , b = bneAndNotZ , out = bneOrbe) ;

    //LW selector
    Mux16(a = aluOut , b = dmOut, sel = lw , out = lwOut) ;
    

    //DM
    RAM16K(in = rd2Out , address = aluOutAddress , load = sw , out = dmOut) ;
    
    //Halt 
   // Mux16(a = currPC , b = true , sel = halt , out[0..11] = newPC ) ; 
    
    //logical left shift
 //   Mux16Way16( sel = rc ,
 //               a = rd1Out , 
 //               b[0] = false , b[1..15] = rd1Out[0..14] ,
 //               c[0..1] = false , c[2..15] = rd1out[0..13] ,
 //               d[0..2] = false , d[3..15] = rd1out[0..12] ,
 //               e[0..3] = false , e[4..15] = rd1out[0..11] ,
 //               f[0..4] = false , f[5..15] = rd1out[0..10] ,
 //               g[0..5] = false , g[6..15] = rd1out[0..9] ,
 //               h[0..6] = false , h[7..15] = rd1out[0..8] ,
 //               i[0..7] = false , i[8..15] = rd1out[0..7] ,
 //               j[0..8] = false , j[9..15] = rd1out[0..6] ,
 //               k[0..9] = false , k[10..15] = rd1out[0..5] ,
 //               l[0..10] = false , l[11..15] = rd1out[0..4] ,
 //               m[0..11] = false , m[12..15] = rd1out[0..3] ,
 //               n[0..12] = false , n[13..15] = rd1out[0..2] ,
 //               o[0..13] = false , o[14..15] = rd1out[0..1] ,
 //               p[0..14] = false , p[15] = rd1out[0] ,
 //               out = llsOut ) ; 
                
    Mux16(sel = lls , a = lwOut , b = lwOut , out = rfwd3 ) ; 
    
    CU(opcode = opcode , out[0] = lw , out[1] = sw , out[2] = nor , out[3] = sub , out[4] = bne , out[5] = be , out[6] = jal , out[7] = alu , out[8] = rfwrite , out[9..10] = rfwd , out[11] = se , out[12] = rd1 , out[13] = halt , out[14] = lls ) ; 
}
