/**
 * Mai Nou Yang & Nathan Moder
 * Single-cycle implementation of the Larc ISA
 */

CHIP Larc {

    PARTS:
    //pc
    PC(in = pcInput , load = true , out = currPC , out[0..11] = imAddress , inc = false , reset = false) ;
    
    //IM
    RAM4K(address = imAddress , out[0..3] = rc , out[4..7] = rb , 
        out[8..11] = ra , out[4..11] = limm ,  out[11] = signExt , 
        out[0..7] = limm2 , out[7] = signExt2 , out[12..15] = opcode) ;

    //Increment PC by 1
    Inc16(in = currPC , out = currPCplusOne) ;

    //Add for bne and beq
    Add16(a = currPCplusOne , b[0..7] = limm , b[8] = signExt  , b[9] = signExt , 
            b[10] = signExt , b[11] = signExt , b[12] = signExt , b[13] = signExt , 
            b[14] = signExt , b[15] = signExt , out = currPCplusOffset) ;

    //jal selector
    Mux16(a = currPCplusOne , b = rd1Out , sel = jal , out = jalOut ) ;

    //be and bne selector
    Mux16(a = jalOut , b = currPCplusOffset , sel = bneOrbe , out = beAndBneOutput ) ;
    
    //halt 
    Mux16(a = beAndBneOutput , b = currPC , sel = halt , out = pcInput ) ; 

    //RFWD selector
    Mux4Way16(a[0..7] = false, a[8..15] = limm2 , b[0..7] = limm2 , 
                b[8] = signExt2 , b[9] = signExt2 , b[10] = signExt2 , 
                b[11] = signExt2 , b[12] = signExt2 , b[13] = signExt2 , 
                b[14] = signExt2 , b[15] = signExt2 , c = currPCplusOne , 
                d = rfwd3 ,  sel = rfwd , out = inForWd) ;

    //RF
    RegisterFile(rr1 = rb , 
                    rr2 = rc , 
                    wr = ra , 
                    wd = inForWd , 
                    load = rfwrite , 
                    rd1 = rd1Out , 
                    rd1[0..14] = lsIn1 , 
                    rd1[0..13] = lsIn2 ,
                    rd1[0..12] = lsIn3 ,
                    rd1[0..11] = lsIn4 ,
                    rd1[0..10] = lsIn5 ,
                    rd1[0..9] = lsIn6 ,
                    rd1[0..8] = lsIn7 ,
                    rd1[0..7] = lsIn8 ,
                    rd1[0..6] = lsIn9 ,
                    rd1[0..5] = lsIn10 ,
                    rd1[0..4] = lsIn11 ,
                    rd1[0..3] = lsIn12 ,
                    rd1[0..2] = lsIn13 ,
                    rd1[0..1] = lsIn14 ,
                    rd1[0] = lsIn15 ,
                    rd2 = rd2Out) ;

    //SE
    Mux4(a[0..3] = ra , b[0..3] = rc ,  sel = se , out = seOut, out[3] = seOutSign) ;

    //RD1 selector
    Mux16(a = false , b = rd1Out , sel = rd1 , out = rd1Selector) ;

    //RD2/ALU selector
    Mux16(a = rd2Out , b[0..3] = seOut , b[4] = seOutSign , b[5] = seOutSign , b[6] = seOutSign , 
            b[7] = seOutSign , b[8] = seOutSign , b[9] = seOutSign , b[10] = seOutSign , 
            b[11] = seOutSign , b[12] = seOutSign , b[13] = seOutSign , b[14] = seOutSign , 
            b[15] = seOutSign , sel = alu , out = rd2Selector) ;

    //ALU
    ALU(a = rd1Selector , b = rd2Selector , sub = sub , nor = nor , z = z , out = aluOut , out[0..13] = aluOutAddress) ;

    //bne and be circuit
    Not(in = z , out = notZ) ;
    And(a = be , b = z , out = beAndZ) ;
    And(a = bne , b = notZ , out = bneAndNotZ) ;
    Or(a = beAndZ , b = bneAndNotZ , out = bneOrbe) ;

    //LW selector
    Mux16(a = aluOut , b = dmOut, sel = lw , out = lwOut) ;
    

    //DM
    RAM16K(in = rd2Out , address = aluOutAddress , load = sw , out = dmOut) ;
    
    /*
    *encoding: Opcode (12..15) , Dest Reg (8..11) , Src Reg (4..7) , Sft Amt (0..3)
    *We added a single Mux16Way16 so the impact on CPU performance should be minimal. 
    *Justification - we have hardcoded amount of zeros to correspond to the selector for the
    *selected shift value. 
    *Usage examples: multiply by a power of 2 quickly 
    *Test code example:
    *load Larc.hdl,
    *
    *set RAM4K[0]  %X8101,   // 1.  li  R1 1         R1  <-- 1                  
    *set RAM4K[1]  %X4211,   // 2.  lls R1 R2 1      R2  <-- 2
    *set RAM4K[2]  %X4315,   // 3.  lls R1 R3 5      R15 <-- 32
    *set RAM4K[3]  %X441F,   // 4.  lls R1 R4 15     R3  <-- -32,768 
    *set RAM4K[4]  %XF000    // 5. halt             
    *;
    *
    *repeat 7 { 
    *  tick, tock;
    *}
    */
    //logical left shift
    Mux16Way16( sel = rc ,
                a = rd1Out , 
                b[0] = false , b[1..15] = lsIn1 ,
                c[0..1] = false , c[2..15] = lsIn2 ,
                d[0..2] = false , d[3..15] = lsIn3 ,
                e[0..3] = false , e[4..15] = lsIn4 ,
                f[0..4] = false , f[5..15] = lsIn5 ,
                g[0..5] = false , g[6..15] = lsIn6 ,
                h[0..6] = false , h[7..15] = lsIn7 ,
                i[0..7] = false , i[8..15] = lsIn8 ,
                j[0..8] = false , j[9..15] = lsIn9 ,
                k[0..9] = false , k[10..15] = lsIn10 ,
                l[0..10] = false , l[11..15] = lsIn11 ,
                m[0..11] = false , m[12..15] = lsIn12 ,
                n[0..12] = false , n[13..15] = lsIn13 ,
                o[0..13] = false , o[14..15] = lsIn14 ,
                p[0..14] = false , p[15] = lsIn15 ,
                out = llsOut ) ; 
                
    Mux16(sel = lls , a = lwOut , b = llsOut , out = rfwd3 ) ; 
    
    CU(opcode = opcode , 
        out[0] = lw , 
        out[1] = sw , 
        out[2] = nor , 
        out[3] = sub , 
        out[4] = bne , 
        out[5] = be , 
        out[6] = jal , 
        out[7] = alu , 
        out[8] = rfwrite , 
        out[9..10] = rfwd , 
        out[11] = se , 
        out[12] = rd1 , 
        out[13] = halt , 
        out[14] = lls ) ; 
}
